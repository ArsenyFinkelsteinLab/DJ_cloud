"""This module was auto-generated by datajoint from an existing schema"""

import datajoint as dj
import numpy as np
import scipy
from scipy import sparse
import math
from math import *
import os


dj.config['database.host'] = 'datajoint.mesoscale-activity-map.org'
dj.config['database.user'] = 'lee'
dj.config['database.password'] = 'verify'
conn = dj.conn()


schema = dj.Schema('lee_meso_analysis')

exp2 = dj.VirtualModule('exp2', 'arseny_s1alm_experiment2')
img = dj.VirtualModule('img', 'arseny_learning_imaging')
stimanal = dj.VirtualModule('stimanal', 'arseny_learning_photostim_anal')
lab = dj.VirtualModule('lab', 'map_lab')
meso = dj.VirtualModule('meso', 'lee_meso_analysis')
tracking = dj.VirtualModule('tracking', 'arseny_learning_tracking')


def FetchChunked(relation_area, relation_tot, idx_name, val_name, chunk_size):
    idx = relation_tot.fetch(idx_name, order_by=idx_name)
    num_elements = len(idx)
    num_chunks = (num_elements + (chunk_size - 1)) // chunk_size
    parts = []
    for i_chunk in range(num_chunks):
        i = i_chunk * chunk_size + 1
        # Don't need to manually check for the remainder; relation does it
        rel_part = relation_area & f"{idx_name} >= {i}" & f"{idx_name} < {i + chunk_size}"
        parts.append(np.asarray(rel_part.fetch(val_name, order_by=idx_name)))
    return np.concatenate(parts)


def MakeBins(F, bin_size):
    ceiled_bin_size = math.ceil(bin_size)
    if ceiled_bin_size == 0:
        return F
    num_bins = len(F) // ceiled_bin_size
    return [sum(F[i * ceiled_bin_size : (i + 1) * ceiled_bin_size]) / ceiled_bin_size for i in range(num_bins)]


def NormalizeF(F_binned, threshold, flag_zscore):
    if threshold > 0:
        F_zscored = scipy.stats.zscore(F_binned, 1)
        for i, fzs in enumerate(F_zscored):
            if fzs <= threshold:
                F_binned[i] = 0
    if flag_zscore: # zscoring the data
        return scipy.stats.zscore(F_binned, 1)
    else: # only centering the data
        return [f - fm for f, fm in zip(F_binned, np.mean(F_binned, 1))]


def FloatRange(start, stop, step):
    num_steps = int((stop - start) / step) + 1
    return [start + i * step for i in range(num_steps)]


def reduced_reg(X,Y,rank,sigma):
    mX = np.mean(X, axis = 1, keepdims=True)
    mY = np.mean(Y, axis = 1, keepdims=True)
    X = X - mX
    Y = Y - mY

    CXX = np.dot(X.T,X) + sigma * np.identity(np.size(X,1))
    CXY = np.dot(X.T,Y)
    B_OLS = np.dot(np.linalg.pinv(CXX), CXY)
    
    Y_OLS = np.dot(X,B_OLS)
    _U, _S, V = np.linalg.svd(Y_OLS, full_matrices=False)
    
    B = B_OLS
    Vr = 0
    if rank > 0:
        V = V.T
        Vr = V[:,:rank]
        B = np.dot(B, np.dot(Vr,Vr.T))

    err = Y - np.dot(X,B)
    err = err.flatten()
    mse = np.mean(np.power(err,2))
    Y = Y.flatten()
    ss = np.mean(np.power(Y,2))

    return mse, ss, B, Vr

def get_trial_times_relative_to_lick(key, frame_rate, time_bin, flag_electric_video):

    TrialsStartFrame = ((img.FrameStartTrial & key) - tracking.VideoGroomingTrial).fetch('session_epoch_trial_start_frame', order_by='trial')
    trial_num = ((img.FrameStartTrial & key) - tracking.VideoGroomingTrial).fetch('trial', order_by='trial')

    if len(TrialsStartFrame) == 0:
        TrialsStartFrame = (img.FrameStartFile & key).fetch('session_epoch_file_start_frame', order_by='session_epoch_file_num')
        trial_num = ((exp2.BehaviorTrial & key) - tracking.VideoGroomingTrial).fetch('trial', order_by='trial')
        TrialsStartFrame = TrialsStartFrame[trial_num]

    if flag_electric_video == 1:
        LICK_VIDEO = []  # We align based on electric lickport, even if video does not exist
    elif flag_electric_video == 2:
        # We align based on video if it exists
        # We align to the first video-detected lick after lickport movement
        LICK_VIDEO = ((tracking.VideoNthLickTrial & key) - tracking.VideoGroomingTrial).fetch('lick_time_onset_relative_to_trial_start')

    go_time = (((exp2.BehaviorTrial.Event & key) - tracking.VideoGroomingTrial) & 'trial_event_type="go"').fetch('trial_event_time')
    LICK_ELECTRIC = ((exp2.ActionEvent & key) - tracking.VideoGroomingTrial).fetch()

    start_file = np.zeros(len(trial_num))
    end_file = np.zeros(len(trial_num))
    lick_file = np.zeros(len(trial_num))
   
    for i_tr in range(len(trial_num)):
        if len(LICK_VIDEO) > 0:
            all_licks = LICK_VIDEO[LICK_VIDEO['trial'] == trial_num[i_tr]]['lick_time_onset_relative_to_trial_start']
            licks_after_go = all_licks[all_licks > go_time[i_tr]]
        else:
            all_licks = LICK_ELECTRIC[LICK_ELECTRIC['trial'] == trial_num[i_tr]]['action_event_time']
            licks_after_go = all_licks[all_licks > go_time[i_tr]]
        
        if len(licks_after_go) > 0:
            start_file[i_tr] = TrialsStartFrame[i_tr] + int(float(licks_after_go[0]) * frame_rate) + int(time_bin[0] * frame_rate)
            end_file[i_tr] = start_file[i_tr] + int(float(time_bin[1] - time_bin[0]) * frame_rate) - 1
                        
            if start_file[i_tr] <= 0:
                start_file[i_tr] = float('nan')
                end_file[i_tr] = float('nan')

        else:
            start_file[i_tr] = float('nan')
            end_file[i_tr] = float('nan')

    return start_file, end_file


def get_partition_by_lick(F,imaging_frame_rate,key):

    start_bin = -4
    end_bin = 6
    start_file, end_file = get_trial_times_relative_to_lick(key, imaging_frame_rate, [start_bin, end_bin], 1)

    num_trials = len(start_file)

    F_before_lick = []
    F_after_lick = []

    for i_tr in range(num_trials):

        start_frame = start_file[i_tr]
        if isnan(start_frame):
            continue

        start_frame = int(start_frame)
        end_frame = int(end_file[i_tr])
        lick_frame = start_frame + int((end_frame - start_frame)/2)

        tmp_before = F[:, start_frame : lick_frame]
        tmp_after = F[:, lick_frame+1 : end_frame]

        F_before_lick.append(tmp_before)
        F_after_lick.append(tmp_after)

    return np.concatenate(F_before_lick,axis=1), np.concatenate(F_after_lick,axis=1)



@schema
class CommSubspaceLick(dj.Computed):
    definition = """
    -> exp2.SessionEpoch
    -> meso.SourceBrainArea
    -> meso.TargetBrainArea
    threshold_for_event  : double                       # threshold in deltaf_overf
    time_bin             : double                       # time window used for binning the data. 0 means no binning
    before_lick_flag     : int                          # 0 if before lick, 1 if after
    ---
    r2            : blob
    """

    @property
    def key_source(self):
        return (exp2.SessionEpoch*meso.SourceBrainArea*meso.TargetBrainArea & img.ROIdeltaF & img.ROIBrainArea & stimanal.MiceIncluded) - exp2.SessionEpochSomatotopy
    
    def make(self, key):
    	# So far the code is only correct for threshold == 0
        threshold_for_event = 0 # [0, 1, 2]

        nranks = 200

        rel_temp = img.Mesoscope & key
        time_bin_vector = [0]

        flag_zscore = 1
        sigma = 1

        rel_FOVEpoch = img.FOVEpoch & key
        rel_FOV = img.FOV & key
        rel_data_area = (img.ROIdeltaF*img.ROIBrainArea) - img.ROIBad
        rel_data_tot = (img.ROIdeltaF & key) - img.ROIBad

        if 'imaging_frame_rate' in rel_FOVEpoch.heading.secondary_attributes:
            imaging_frame_rate = rel_FOVEpoch.fetch1('imaging_frame_rate')
        else:
            imaging_frame_rate = rel_FOV.fetch1('imaging_frame_rate')

        target_brain_area = key['target_brain_area']
        source_brain_area = key['source_brain_area']

        if target_brain_area == source_brain_area:
            return
        
        source_key = key
        source_key.pop('source_brain_area')
        source_key.pop('target_brain_area')
        source_key['brain_area'] = source_brain_area
        F_source = FetchChunked(rel_data_area & source_key, rel_data_tot & source_key, 'roi_number', 'dff_trace', 500)
        target_key = source_key
        target_key['brain_area'] = target_brain_area
        F_target = FetchChunked(rel_data_area & target_key, rel_data_tot & target_key, 'roi_number', 'dff_trace', 500)


        for time_bin in time_bin_vector:

            insert_key = key
            insert_key.pop('brain_area')
            insert_key['source_brain_area'] = source_brain_area                    
            insert_key['target_brain_area'] = target_brain_area
            
            F_source_binned = np.array([MakeBins(Fi.flatten(), time_bin * imaging_frame_rate) for Fi in F_source])
            F_target_binned = np.array([MakeBins(Fi.flatten(), time_bin * imaging_frame_rate) for Fi in F_target])
            nneurons = F_source_binned.shape[0]
            nneurons2 = F_target_binned.shape[0]
            nneurons = min(nneurons,nneurons2)
            
            if nneurons < 500:

                insert_key2 = {**insert_key, 'time_bin': time_bin, 'threshold_for_event': threshold_for_event}
                self.insert1({**insert_key2, 'r2': r2_all}, allow_direct_insert=True)
                return
        
            
            nneurons = 500
            F_source_binned = F_source_binned[:nneurons,:]
            F_target_binned = F_target_binned[:nneurons,:]


            F_source_partitioned = get_partition_by_lick(F_source_binned,imaging_frame_rate,key)
            F_target_partitioned = get_partition_by_lick(F_target_binned,imaging_frame_rate,key)

            rank_vals = (np.floor(np.linspace(0, nneurons, nranks, endpoint=True))).astype(int)
            num_pieces = 2
  
            for j in range(num_pieces):

                r2_all = np.empty((nranks, 2))
                r2_all[:] = np.nan

                F_source_part = F_source_partitioned[j]
                F_target_part = F_target_partitioned[j]
                for i in range(nranks):
                    rank = rank_vals[i]
                    mse, ss, B, V = reduced_reg(F_source_part.T,F_target_part.T,rank,sigma)
                    r2_all[i,0] = 1 - mse / ss

                r2_all[:,1] = rank_vals.T

                insert_key2 = {**insert_key, 'time_bin': time_bin, 'threshold_for_event': threshold_for_event, 'before_lick_flag': j}
                self.insert1({**insert_key2, 'r2': r2_all}, allow_direct_insert=True)
